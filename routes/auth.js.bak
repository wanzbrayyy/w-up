const express = require('express');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const geoip = require('geoip-lite');
const useragent = require('useragent');
const User = require('../models/user');
const { loginLimiter, registerLimiter } = require('../middleware/limiters');
const {
    generatePasskeyLoginOptions,
    verifyPasskeyLogin
} = require('../utils/passkey');
const router = express.Router();

const PASS_EXPIRY_DAYS = 90;
const MAX_LOGIN_ATTEMPTS = 5;
const LOCK_TIME = 15 * 60 * 1000; 

router.post('/register', registerLimiter, async (req, res) => {
    try {
        const { username, password, referralCode } = req.body;
        if (!username || !password) return res.status(400).json({ message: 'Required fields missing.' });
        
        const existingUser = await User.findOne({ username });
        if (existingUser) return res.status(400).json({ message: 'Username exists.' });

        let referrer = null;
        if (referralCode) {
            referrer = await User.findOne({ referralCode });
            if (referrer) {
                referrer.storageBonus += 52428800;
                await referrer.save();
            }
        }

        const user = new User({ 
            username, 
            password, 
            referredBy: referrer?._id, 
            storageBonus: referrer ? 52428800 : 0 
        });
        await user.save();
        res.status(201).json({ message: 'User registered.' });
    } catch (error) {
        res.status(500).json({ message: 'Registration failed.' });
    }
});

router.post('/login', loginLimiter, async (req, res) => {
    try {
        const { username, password } = req.body;
        const user = await User.findOne({ username });
        const ip = req.ip || req.connection.remoteAddress;
        
        if (!user) return res.status(401).json({ message: 'Invalid credentials.' });

        if (user.lockUntil && user.lockUntil > Date.now()) {
            return res.status(423).json({ 
                message: `Account locked. Try again after ${new Date(user.lockUntil).toLocaleTimeString()}` 
            });
        }

        const isMatch = await user.comparePassword(password);
        if (!isMatch) {
            user.loginAttempts += 1;
            user.failedLogins.push({ ip, reason: 'Wrong Password' });
            
            if (user.loginAttempts >= MAX_LOGIN_ATTEMPTS) {
                user.lockUntil = Date.now() + LOCK_TIME;
                user.failedLogins.push({ ip, reason: 'Account Locked' });
            }
            await user.save();
            return res.status(401).json({ 
                message: user.lockUntil ? 'Account locked due to too many failed attempts.' : 'Invalid credentials.' 
            });
        }

        const daysSinceChange = (Date.now() - new Date(user.passwordChangedAt).getTime()) / (1000 * 60 * 60 * 24);
        if (daysSinceChange > PASS_EXPIRY_DAYS) {
            return res.status(403).json({ status: 'password_expired', message: 'Password expired. Please change it.' });
        }

        user.loginAttempts = 0;
        user.lockUntil = undefined;

        if (user.isTwoFactorEnabled) {
            const tempToken = jwt.sign({ id: user._id, partial: true }, process.env.JWT_SECRET, { expiresIn: '5m' });
            res.cookie('temp_token', tempToken, { httpOnly: true });
            await user.save();
            return res.status(200).json({ status: '2fa_required', message: '2FA required.' });
        }

        const agent = useragent.parse(req.headers['user-agent']);
        const geo = geoip.lookup(ip);
        const location = geo ? `${geo.city}, ${geo.country}` : 'Unknown';
        const deviceId = crypto.randomBytes(16).toString('hex');
        
        const accessToken = jwt.sign({ id: user._id, username: user.username }, process.env.JWT_SECRET, { expiresIn: '15m' });
        const refreshToken = jwt.sign({ id: user._id, deviceId }, process.env.JWT_SECRET, { expiresIn: '7d' });

        user.sessions.push({
            refreshToken,
            deviceId,
            ip,
            os: agent.os.toString(),
            browser: agent.toAgent(),
            location
        });

        user.loginHistory.push({
            ip,
            os: agent.os.toString(),
            browser: agent.toAgent(),
            location
        });
        
        if (user.loginHistory.length > 20) user.loginHistory.shift();

        await user.save();

        res.cookie('token', accessToken, { httpOnly: true, maxAge: 900000 });
        res.cookie('refresh_token', refreshToken, { httpOnly: true, maxAge: 604800000 });
        
        res.status(200).json({ message: 'Login successful.' });
    } catch (error) {
        res.status(500).json({ message: 'Login error.' });
    }
});

router.post('/login/2fa', async (req, res) => {
    const { code } = req.body;
    const tempToken = req.cookies.temp_token;
    if(!tempToken) return res.status(401).json({ message: 'Session expired.' });

    try {
        const decoded = jwt.verify(tempToken, process.env.JWT_SECRET);
        const user = await User.findById(decoded.id);
        
        const speakeasy = require('speakeasy');
        const verified = speakeasy.totp.verify({
            secret: user.twoFactorSecret.ascii,
            encoding: 'ascii',
            token: code
        });

        if(verified) {
            const agent = useragent.parse(req.headers['user-agent']);
            const deviceId = crypto.randomBytes(16).toString('hex');
            
            const token = jwt.sign({ id: user._id, username: user.username }, process.env.JWT_SECRET, { expiresIn: '15m' });
            const refreshToken = jwt.sign({ id: user._id, deviceId }, process.env.JWT_SECRET, { expiresIn: '7d' });
            
            user.sessions.push({
                refreshToken,
                deviceId,
                ip: req.ip || req.connection.remoteAddress,
                os: agent.os.toString(),
                browser: agent.toAgent(),
                location: 'Unknown (2FA)'
            });
            await user.save();

            res.clearCookie('temp_token');
            res.cookie('token', token, { httpOnly: true, maxAge: 900000 });
            res.cookie('refresh_token', refreshToken, { httpOnly: true, maxAge: 604800000 });
            res.json({ message: 'Login successful' });
        } else {
            res.status(400).json({ message: 'Invalid 2FA code' });
        }
    } catch(e) {
        res.status(401).json({ message: 'Error verifying 2FA' });
    }
});

router.post('/refresh-token', async (req, res) => {
    try {
        const oldRefreshToken = req.cookies.refresh_token;
        if (!oldRefreshToken) return res.status(401).json({ message: 'No refresh token.' });

        const decoded = jwt.verify(oldRefreshToken, process.env.JWT_SECRET);
        const user = await User.findById(decoded.id);
        if (!user) return res.status(403).json({ message: 'User not found.' });

        const sessionIndex = user.sessions.findIndex(s => s.refreshToken === oldRefreshToken);
        if (sessionIndex === -1) {
            res.clearCookie('token');
            res.clearCookie('refresh_token');
            return res.status(403).json({ message: 'Invalid session.' });
        }

        const newAccessToken = jwt.sign({ id: user._id, username: user.username }, process.env.JWT_SECRET, { expiresIn: '15m' });
        const newRefreshToken = jwt.sign({ id: user._id, deviceId: decoded.deviceId }, process.env.JWT_SECRET, { expiresIn: '7d' });

        user.sessions[sessionIndex].refreshToken = newRefreshToken;
        user.sessions[sessionIndex].lastActive = Date.now();
        await user.save();

        res.cookie('token', newAccessToken, { httpOnly: true, maxAge: 900000 });
        res.cookie('refresh_token', newRefreshToken, { httpOnly: true, maxAge: 604800000 });

        res.json({ message: 'Token refreshed.' });
    } catch (error) {
        res.status(403).json({ message: 'Invalid refresh token.' });
    }
});
router.post('/api/auth/passkey/login-options', async (req, res) => {
    try {
        // Ambil user berdasarkan username jika ada, atau biarkan kosong untuk discoverable credentials
        const { username } = req.body;
        let user;
        if (username) {
            user = await User.findOne({ username });
        }
        
        const options = await generatePasskeyLoginOptions(user);
        
        if (options.error) {
            return res.status(404).json({ error: options.error });
        }
        
        res.json(options);
    } catch(e) {
        res.status(500).json({ error: e.message });
    }
});

router.post('/api/auth/passkey/verify-login', async (req, res) => {
    const body = req.body;
    try {
        const userID = body.response.userHandle;
        if (!userID) {
            throw new Error("User handle not found in response.");
        }
        
        const user = await User.findById(userID);
        if (!user) {
            return res.status(404).json({ error: "User not found." });
        }

        const verification = await verifyPasskeyLogin(user, body);

        if (verification.verified) {
            // Jika berhasil, buat sesi login seperti biasa
            const accessToken = jwt.sign({ id: user._id, username: user.username }, process.env.JWT_SECRET, { expiresIn: '15m' });
            const refreshToken = jwt.sign({ id: user._id, deviceId: crypto.randomBytes(16).toString('hex') }, process.env.JWT_SECRET, { expiresIn: '7d' });

            res.cookie('token', accessToken, { httpOnly: true });
            res.cookie('refresh_token', refreshToken, { httpOnly: true });
            
            return res.json({ verified: true });
        }

        res.status(400).json({ verified: false, error: 'Verification failed' });
    } catch (e) {
        res.status(400).json({ error: e.message });
    }
});

router.get('/logout', async (req, res) => {
    const refreshToken = req.cookies.refresh_token;
    if (refreshToken) {
        try {
            const decoded = jwt.verify(refreshToken, process.env.JWT_SECRET);
            await User.updateOne({ _id: decoded.id }, { $pull: { sessions: { refreshToken } } });
        } catch(e) {}
    }
    res.clearCookie('token');
    res.clearCookie('refresh_token');
    res.clearCookie('temp_token');
    res.redirect('/login');
});


module.exports = router;