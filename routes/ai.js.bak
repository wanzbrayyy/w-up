const express = require('express');
const router = express.Router();
const File = require('../models/file');
const User = require('../models/user');
const AiLog = require('../models/aiLog');
const { extractContent, summarizeText, searchInText } = require('../utils/fileProcessor');
const { translateText } = require('../utils/tr');
const { getDocsContent } = require('../utils/docsLoader'); 
const auth = require('../middleware/auth');

function maskPII(text) {
    return text
        .replace(/\b[\w\.-]+@[\w\.-]+\.\w{2,4}\b/g, '[EMAIL PROTECTED]')
        .replace(/\b(\+62|0)[0-9]{9,12}\b/g, '[PHONE PROTECTED]');
}

router.post('/chat', auth.protectApi, async (req, res) => {
    try {
        const { message, context } = req.body;
        const userId = req.user.id;
        
        const userLang = context.language ? context.language.split('-')[0] : 'en';
        
        const englishQuery = await translateText(message, 'en', 'auto');
        const cleanMsg = englishQuery.toLowerCase().trim();
        
        let responseText = "";
        let action = null;

        if (cleanMsg.includes('who am i') || cleanMsg.includes('my profile')) {
            const user = await User.findById(userId);
            responseText = `You are **${user.username}**.\nPlan: **${user.plan.toUpperCase()}**\nStatus: ${user.isVerified ? 'Verified' : 'Unverified'}`;
        }
        else if (cleanMsg.includes('storage') || cleanMsg.includes('quota')) {
            const count = await File.countDocuments({ owner: userId, deletedAt: null });
            const user = await User.findById(userId);
            const usedMB = (user.storageUsed / 1024 / 1024).toFixed(2);
            responseText = `**Storage Stats:**\nFiles: ${count}\nUsed: **${usedMB} MB**\nLimit: **${(user.storageLimit/1024/1024/1024).toFixed(0)} GB**`;
        }
        else if (cleanMsg.startsWith('read file') || cleanMsg.startsWith('open file')) {
            const filename = cleanMsg.replace(/^(read|open) file/, '').trim();
            const file = await File.findOne({ owner: userId, originalName: { $regex: filename, $options: 'i' }, deletedAt: null });

            if (!file) {
                responseText = `File "${filename}" not found.`;
            } else if (file.owner.toString() !== userId && !file.collaborators.includes(userId)) {
                responseText = "Permission Denied: You do not own this file.";
            } else {
                try {
                    const content = await extractContent(file);
                    const snippet = content.length > 800 ? content.substring(0, 800) + "\n...(truncated)" : content;
                    responseText = `**${file.originalName}** (${file.contentType}):\n\`\`\`\n${snippet}\n\`\`\``;
                } catch (e) {
                    responseText = `Error reading file: ${e.message}`;
                }
            }
        }
        else if (cleanMsg.startsWith('summarize') || cleanMsg.startsWith('summary')) {
            const filename = cleanMsg.replace(/^(summarize|summary)/, '').trim();
            const file = await File.findOne({ owner: userId, originalName: { $regex: filename, $options: 'i' }, deletedAt: null });

            if (!file) {
                responseText = "File not found.";
            } else if (file.owner.toString() !== userId && !file.collaborators.includes(userId)) {
                responseText = "Permission Denied.";
            } else {
                try {
                    const content = await extractContent(file);
                    const summary = summarizeText(content);
                    responseText = `**Summary of ${file.originalName}:**\n\n${summary}`;
                } catch (e) {
                    responseText = "Could not generate summary. Supported formats: PDF, DOCX, Text, Images.";
                }
            }
        }
        else if (cleanMsg.includes('search in file')) {
            const parts = cleanMsg.split(' in file ');
            if (parts.length === 2) {
                const query = parts[0].replace('search', '').trim();
                const filename = parts[1].trim();
                const file = await File.findOne({ owner: userId, originalName: { $regex: filename, $options: 'i' }, deletedAt: null });

                if (!file) {
                    responseText = "File not found.";
                } else if (file.owner.toString() !== userId && !file.collaborators.includes(userId)) {
                    responseText = "Permission Denied.";
                } else {
                    try {
                        const content = await extractContent(file);
                        const results = searchInText(content, query);
                        responseText = results ? `**Found in ${file.originalName}:**\n\n${results}` : `No matches found for "${query}".`;
                    } catch (e) {
                        responseText = "Search failed. Supported formats: PDF, DOCX, Text.";
                    }
                }
            } else {
                responseText = "Format: search [text] in file [filename]";
            }
        }
        else if (cleanMsg.startsWith('check virus') || cleanMsg.startsWith('scan status')) {
            const filename = cleanMsg.replace(/^(check virus|scan status)/, '').trim();
            const file = await File.findOne({ owner: userId, originalName: { $regex: filename, $options: 'i' }, deletedAt: null });
            
            if (!file) {
                responseText = "File not found.";
            } else {
                const status = file.virusScan?.status || 'unscanned';
                const color = status === 'clean' ? 'ðŸŸ¢' : (status === 'infected' ? 'ðŸ”´' : 'âšª');
                responseText = `**${file.originalName}**\nScan Status: ${color} **${status.toUpperCase()}**\nLast Checked: ${file.virusScan?.lastChecked ? new Date(file.virusScan.lastChecked).toLocaleString() : 'Never'}`;
            }
        }
        else if (cleanMsg.startsWith('get link') || cleanMsg.startsWith('download link')) {
            const filename = cleanMsg.replace(/^(get|download) link/, '').trim();
            const file = await File.findOne({ owner: userId, originalName: { $regex: filename, $options: 'i' }, deletedAt: null });
            
            if (!file) {
                responseText = "File not found.";
            } else {
                const link = `${req.protocol}://${req.get('host')}/w-upload/file/${file.customAlias}`;
                responseText = `Here is your download link for **${file.originalName}**:\n${link}`;
            }
        }
        else if (cleanMsg.startsWith('file info') || cleanMsg.startsWith('metadata')) {
            const filename = cleanMsg.replace(/^(file info|metadata)/, '').trim();
            const file = await File.findOne({ owner: userId, originalName: { $regex: filename, $options: 'i' }, deletedAt: null });
            
            if (!file) {
                responseText = "File not found.";
            } else {
                responseText = `**Metadata for ${file.originalName}**:\n- Size: ${(file.size/1024/1024).toFixed(2)} MB\n- Type: ${file.contentType}\n- Uploaded: ${new Date(file.createdAt).toLocaleString()}\n- Downloads: ${file.downloads}\n- Hash: ${file.md5Hash || 'N/A'}`;
            }
        }
        else if (cleanMsg.includes('error')) {
            if (context.hasError && context.errorMessage) {
                responseText = `**Error Analysis:** ${context.errorMessage}\n\nThis typically occurs due to validation or connectivity issues.`;
            } else {
                responseText = "No visible errors detected.";
            }
        }
        else if (cleanMsg.includes('go to')) {
            const page = cleanMsg.includes('settings') ? '/profile' : '/dashboard';
            responseText = "Navigating...";
            action = { type: 'navigate', url: page };
        }
        else if (cleanMsg.includes('help')) {
            responseText = "Try: Read file [name], Summarize [name], Search [text] in file [name], Check virus [name], Get link [name], File info [name].";
        }
        else {
            responseText = "I can read PDFs/Images, summarize docs, and search inside files. Try 'Summarize my-doc.pdf'.";
        }

        const finalResponse = await translateText(responseText, userLang, 'en');
        const maskedResponse = maskPII(finalResponse);

        const log = new AiLog({
            user: userId,
            query: message,
            response: maskedResponse,
            ip: req.ip
        });
        await log.save();

        res.json({ response: maskedResponse, action, logId: log._id });

    } catch (error) {
        console.error(error);
        res.status(500).json({ response: "System Error." });
    }
});

router.post('/feedback/:id', auth.protectApi, async (req, res) => {
    try {
        const { type } = req.body; 
        await AiLog.findByIdAndUpdate(req.params.id, { feedback: type });
        res.json({ message: 'Feedback received' });
    } catch (e) {
        res.status(500).json({ message: 'Error' });
    }
});

module.exports = router;